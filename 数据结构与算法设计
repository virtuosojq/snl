在词法分析中token设计如下：
struct token
{
    int line;//行数
    string lex;//词法信息
    string uplex;//大写词法信息标志
    int pos;//语义信息
};//保留字的pos为-1,分界符的pos=-2,错误的pos为-3,注释为-4
可以通过pos信息来对语法分析的输出进行筛选。

###
vector<token> tokenlist;//保存所有的token序列
vector<string> idTable;//标识符表
vector<string> intcTable;//整数表
采用STL中的动态数组来存储token序列，即为tokenlist,便于动态改变与访问，其中idTable和intcTable分别存储标识符和无符号整数，在语法分析步骤不用输入。

对于SNL中的保留字，单独建立一个字符串数组进行保存；
tring rword[21]={ "begin","integer","char","program","array","of","record","end","var","procedure","if","then","else","fi","while","do","endwh","read","write","return","type" };

算法设计：
词法分析采用DFA的思想实现。
1、采用库函数fgetc()和ungetc()实现向前搜索及回退；
2、对于空格和回车不作为区别不同token的边界；
3、每当遇到一个分界符时，读完这个部分即生成一个token;
4、对于注释,从左大括号起，直到遇见右大括号，中间的部分都忽略。
词法分析中最主要的生成token的函数的设计思想如下：
（1）读取SNL程序文本；
（2）对于空格，回车等格式符号都予以过滤；
（3）判断读入字符的类型，总共有3种情况：
若头一个字符为字母，则只可能为标识符或保留字，一直往后读到第一个不为字母或符号的数字为止，判断整体字符串是否为保留字，若是，则生成保留字token,若不是，则生成标识符token;
若头一个字符为数字，则只可能为数字，读到不为数字的字符为止，生成整数token;
若头一个字符为特殊界限符（包括运算符，单双分界符，数组标志等），则直接返回一个符号token，遇到的若是：，要向后判断一个字符，不是=则返回。
遇到的是其他情况，则返回错误。

每当生成一个token，都保留到tokenlist中。


（2）语法分析
数据结构：
vector<string>data;//输入数据，全为终极符
vector <int> row;//表示行数，用于语法分析中的错误显示
若词法分析没有错误，则把token中没有错误的token的语义和行号分别保存在以上两个动态数组中，其中data部分中含有字母的部分要为大写，便于与产生式进行匹配。

vector<string> Left;  //保存产生式的左部
vector< vector<string> >Right;  //保存产生式的右部
这两个动态数组用来保存产生式。
stack<string>sem;//分析栈
stack初始化为第一个产生式左端，之后要替换的话采用的是逆序压入的方法。
map< int,vector<string> >Predicts;//保存predict集
predict集从宏观上来说是一对一的关系，其中后一个一代表predict集中的多个字符串，整个predict集是通过读取文件形成的。
map< string,map<string,int> >LL1;//ll1分析表，由predict集和产生式左端形成的一个表。是匹配转换的最重要部分。
算法设计：
LL（1）语法分析程序由两部分组成的：第一部分是语法分析表，也称为LL（1）分析矩阵；第二部分是语法分析驱动程序。
LL（1）矩阵的作用是帮助当前非终极符和当前输入符确定应该选择的语法规则，它的行对应非终极符，列对应终极符，矩阵的值有两种：一种是产生式编号。另外一种是错误编号，错误编号默认设为-1。
LL（1）分析程序工作过程首先初始化，即把开始符压入栈中，以后的每步分析必是下面的四种情况之一：
（1）分析栈的栈顶元素是终极符，则看其是否与输入流的头符相匹配，如果匹配成功，则去掉栈顶元素并读入下一个单词；若匹配不成功，则报错。
（2）栈顶是非终极符，则用栈顶和输入流的当前单词去查当前矩阵，如果查得的值是产生式编号，则把对应的产生式右部逆序压入栈中；如果查得的值为错误信息，则报错。
（3）栈已空，输入流不空，这时输入流报错。
（4）若栈已空，输入流也空，则语法分析成功。

